name: Build and Test

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

jobs:
  build-and-test:
    name: ${{ matrix.os }} - Qt ${{ matrix.qt-version }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        qt-version: ['6.10.1']

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Qt
      uses: jurplel/install-qt-action@v4
      with:
        version: ${{ matrix.qt-version }}
        modules: 'qtwebsockets qthttpserver qtwebengine qtwebchannel qtpositioning'
        cache: true

    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libgl1-mesa-dev \
          libxkbcommon-x11-0 \
          libxcb-icccm4 \
          libxcb-image0 \
          libxcb-keysyms1 \
          libxcb-render-util0 \
          libxcb-xinerama0 \
          libxcb-cursor0

    - name: Configure CMake
      run: cmake -B build -DCMAKE_BUILD_TYPE=Release

    - name: Build Application and Tests
      run: cmake --build build --config Release

    # macOS: Create DMG
    - name: Create macOS DMG
      if: runner.os == 'macOS'
      run: |
        # Deploy Qt dependencies into the app bundle
        macdeployqt build/Fang.app -qmldir=qml

    - name: Sign macOS app bundle
      if: runner.os == 'macOS' && vars.MACOS_SIGN_ENABLED == 'true'
      run: |
        # Import signing certificate
        echo "${{ secrets.MACOS_CERT_BASE64 }}" | base64 --decode > certificate.p12
        security create-keychain -p "${{ secrets.MACOS_KEYCHAIN_PASSWORD }}" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "${{ secrets.MACOS_KEYCHAIN_PASSWORD }}" build.keychain
        security import certificate.p12 -k build.keychain -P "${{ secrets.MACOS_CERT_PASSWORD }}" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${{ secrets.MACOS_KEYCHAIN_PASSWORD }}" build.keychain

        # Sign the app bundle and all executables inside
        echo "Signing Fang.app bundle..."
        /usr/bin/codesign --force --deep --sign "${{ secrets.MACOS_SIGNING_IDENTITY }}" \
          --options runtime \
          --entitlements entitlements.plist \
          --timestamp \
          build/Fang.app

        # Verify signature
        codesign --verify --verbose build/Fang.app

        # Clean up
        rm certificate.p12

    - name: Package macOS DMG
      if: runner.os == 'macOS'
      run: |
        # Install create-dmg
        brew install create-dmg

        # Create DMG
        create-dmg \
          --volname "Fang" \
          --window-pos 200 120 \
          --window-size 800 400 \
          --icon-size 100 \
          --icon "Fang.app" 200 190 \
          --hide-extension "Fang.app" \
          --app-drop-link 600 185 \
          "Fang.dmg" \
          "build/Fang.app"

    - name: Sign and notarize macOS DMG
      if: runner.os == 'macOS' && vars.MACOS_SIGN_ENABLED == 'true'
      run: |
        # Sign the DMG
        echo "Signing Fang.dmg..."
        /usr/bin/codesign --force --sign "${{ secrets.MACOS_SIGNING_IDENTITY }}" \
          --timestamp \
          Fang.dmg

        # Notarize the DMG
        echo "Submitting DMG for notarization..."
        xcrun notarytool submit Fang.dmg \
          --apple-id "${{ secrets.APPLE_ID }}" \
          --password "${{ secrets.APPLE_APP_PASSWORD }}" \
          --team-id "${{ secrets.APPLE_TEAM_ID }}" \
          --wait

        # Staple the notarization ticket
        echo "Stapling notarization ticket..."
        xcrun stapler staple Fang.dmg

        echo "macOS DMG signed and notarized successfully"

    # Linux: Create AppImage
    - name: Create Linux AppImage
      if: runner.os == 'Linux'
      run: |
        # Install dependencies
        sudo apt-get install -y libfuse2 file

        # Download linuxdeploy and Qt plugin
        wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        wget https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
        chmod +x linuxdeploy*.AppImage

        # Create AppDir structure
        mkdir -p AppDir/usr/bin
        cp build/Fang AppDir/usr/bin/

        # Copy icon and desktop file
        mkdir -p AppDir/usr/share/applications
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        cp com.mrericsir.Fang.desktop AppDir/usr/share/applications/
        cp qml/images/full_icon.png AppDir/usr/share/icons/hicolor/256x256/apps/com.mrericsir.Fang.png

        # Build AppImage
        # Remove problematic SQL drivers that have missing dependencies (Fang only uses SQLite)
        # This prevents linuxdeploy from trying to deploy them
        echo "Qt installation path: $QT_ROOT_DIR"
        ls -la $QT_ROOT_DIR/plugins/sqldrivers/ || echo "sqldrivers directory not found"
        rm -f $QT_ROOT_DIR/plugins/sqldrivers/libqsqloci.so
        rm -f $QT_ROOT_DIR/plugins/sqldrivers/libqsqlpsql.so
        rm -f $QT_ROOT_DIR/plugins/sqldrivers/libqsqlmimer.so
        rm -f $QT_ROOT_DIR/plugins/sqldrivers/libqsqlibase.so
        rm -f $QT_ROOT_DIR/plugins/sqldrivers/libqsqlodbc.so
        echo "After removal:"
        ls -la $QT_ROOT_DIR/plugins/sqldrivers/

        # Set QML sources path for linuxdeploy-plugin-qt
        export QML_SOURCES_PATHS=qml

        # Manually copy QtWebEngine files (linuxdeploy-plugin-qt doesn't always handle these correctly)
        echo "Copying QtWebEngine resources..."

        # Copy QtWebEngineProcess executable
        if [ -f "$QT_ROOT_DIR/libexec/QtWebEngineProcess" ]; then
          mkdir -p AppDir/usr/libexec
          cp "$QT_ROOT_DIR/libexec/QtWebEngineProcess" AppDir/usr/libexec/
          echo "Copied QtWebEngineProcess"
        fi

        # Copy WebEngine resources directory (pak files, etc.)
        if [ -d "$QT_ROOT_DIR/resources" ]; then
          mkdir -p AppDir/usr/resources
          cp -r "$QT_ROOT_DIR/resources/"* AppDir/usr/resources/
          echo "Copied WebEngine resources:"
          ls -la AppDir/usr/resources/
        fi

        # Copy WebEngine translations
        if [ -d "$QT_ROOT_DIR/translations/qtwebengine_locales" ]; then
          mkdir -p AppDir/usr/translations
          cp -r "$QT_ROOT_DIR/translations/qtwebengine_locales" AppDir/usr/translations/
          echo "Copied WebEngine translations"
        fi

        ./linuxdeploy-x86_64.AppImage --appdir AppDir --plugin qt --output appimage --desktop-file=AppDir/usr/share/applications/com.mrericsir.Fang.desktop --icon-file=AppDir/usr/share/icons/hicolor/256x256/apps/com.mrericsir.Fang.png

        # Rename to simpler name
        mv Fang*.AppImage Fang.AppImage

    # Windows: Create MSI
    - name: Create Windows MSI
      if: runner.os == 'Windows'
      run: |
        # Deploy Qt dependencies (windeployqt automatically includes WebEngine files)
        # Change to Release directory - windeployqt works better when run from the exe directory
        Push-Location build/Release
        Write-Host "Running windeployqt from: $(Get-Location)"
        Write-Host "Qt root: $env:QT_ROOT_DIR"

        # Verify Qt is in PATH
        Write-Host "`nQt bin directory:"
        where.exe windeployqt

        # Check if Fang.exe exists and is valid
        if (Test-Path "Fang.exe") {
            Write-Host "`nFang.exe found:"
            Get-Item Fang.exe | Select-Object Name, Length, LastWriteTime
        } else {
            Write-Error "Fang.exe not found in $(Get-Location)"
            exit 1
        }

        # Get the absolute path to qml directory
        $qmlPath = Resolve-Path "../../qml"
        Write-Host "`nQML directory: $qmlPath"

        # Run windeployqt with explicit release flag
        Write-Host "`nRunning windeployqt..."
        windeployqt Fang.exe --release --qmldir "$qmlPath" --verbose 2

        if ($LASTEXITCODE -ne 0) {
            Write-Error "windeployqt failed with exit code $LASTEXITCODE"
            exit 1
        }

        Pop-Location

        # Verify deployment worked
        Write-Host "`nChecking for Qt DLLs in Release folder:"
        $dlls = Get-ChildItem build/Release/*.dll -ErrorAction SilentlyContinue
        if ($dlls) {
            $dlls | Select-Object Name, @{Name="Size(MB)";Expression={[math]::Round($_.Length/1MB, 2)}}
            Write-Host "`nTotal DLLs: $($dlls.Count)"
        } else {
            Write-Warning "No DLLs found in Release folder!"
        }

        Write-Host "`nTotal files in Release folder:"
        (Get-ChildItem build/Release -Recurse -File).Count

        # Remove build artifacts that shouldn't be in the installer
        Remove-Item -ErrorAction SilentlyContinue build/Release/Fang.exp
        Remove-Item -ErrorAction SilentlyContinue build/Release/Fang.lib
        Remove-Item -ErrorAction SilentlyContinue build/Release/Fang.pdb

        # Install WiX Toolset
        dotnet tool install --global wix

        # Add WiX Heat extension for file harvesting
        wix extension add WixToolset.Heat.Extension

        # Generate file list with heat
        # Use absolute path and -scom to suppress COM/SelfReg warnings
        $buildPath = Resolve-Path "build/Release"
        Write-Host "`nRunning heat to harvest files from: $buildPath"
        heat dir "$buildPath" -cg FangFilesGroup -gg -sfrag -srd -scom -dr FangPath -var var.SourceDir -out build/files.wxs

        # Show how many files were harvested
        $fileCount = (Select-String -Path build/files.wxs -Pattern '<File ').Count
        Write-Host "Heat harvested $fileCount files"

        # Update namespace in generated files.wxs from WiX 3.x to WiX 5
        (Get-Content build/files.wxs) -replace 'http://schemas.microsoft.com/wix/2006/wi', 'http://wixtoolset.org/schemas/v4/wxs' | Set-Content build/files.wxs

        # Build MSI with SourceDir variable pointing to Release folder
        Write-Host "`nBuilding MSI..."
        wix build fang.wxs build/files.wxs -out build/Fang.msi -d SourceDir=build/Release

        # Show MSI size
        $msiSize = (Get-Item build/Fang.msi).Length / 1MB
        Write-Host "`nMSI created: $([math]::Round($msiSize, 2)) MB"

    - name: Sign Windows executable and MSI
      if: runner.os == 'Windows' && vars.WINDOWS_SIGN_ENABLED == 'true'
      run: |
        # Decode certificate from base64 secret and save to file
        $certBytes = [Convert]::FromBase64String("${{ secrets.WINDOWS_CERT_BASE64 }}")
        $certPath = "signing-cert.pfx"
        [IO.File]::WriteAllBytes($certPath, $certBytes)

        # Sign the executable
        Write-Host "Signing Fang.exe..."
        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe" sign `
          /f $certPath `
          /p "${{ secrets.WINDOWS_CERT_PASSWORD }}" `
          /tr http://timestamp.digicert.com `
          /td sha256 `
          /fd sha256 `
          build/Release/Fang.exe

        # Sign the MSI
        Write-Host "Signing Fang.msi..."
        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe" sign `
          /f $certPath `
          /p "${{ secrets.WINDOWS_CERT_PASSWORD }}" `
          /tr http://timestamp.digicert.com `
          /td sha256 `
          /fd sha256 `
          build/Fang.msi

        # Clean up certificate file
        Remove-Item $certPath

        Write-Host "`nSigning completed successfully"

    - name: Upload DMG Installer (macOS)
      if: runner.os == 'macOS'
      uses: actions/upload-artifact@v4
      with:
        name: Fang-macOS-DMG
        path: Fang.dmg

    - name: Upload AppImage (Linux)
      if: runner.os == 'Linux'
      uses: actions/upload-artifact@v4
      with:
        name: Fang-Linux-AppImage
        path: Fang.AppImage

    - name: Upload MSI Installer (Windows)
      if: runner.os == 'Windows'
      uses: actions/upload-artifact@v4
      with:
        name: Fang-Windows-MSI
        path: build/Fang.msi

    - name: Run tests
      run: ctest --test-dir build --output-on-failure --build-config Release
      env:
        QT_QPA_PLATFORM: offscreen  # For Linux headless testing

    - name: Upload test results on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.os }}
        path: build/Testing/Temporary/
